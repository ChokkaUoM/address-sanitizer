#summary AddressSanitizer algorithm

<wiki:toc max_depth="2" />

=Short version=
The run-time library replaces the `malloc` and `free` functions.
The memory around malloc-ed regions (red zones) is poisoned. 
The `free`-ed memory is placed in quarantine and also poisoned.
Every memory access in the program is transformed by the compiler in the following way:

Before:
{{{
*address = ...;  // or: ... = *address;
}}}
After:
{{{
if (IsPoisoned(address) {
  ReportError(address, kAccessSize, kIsWrite);
}
*address = ...;  // or: ... = *address;
}}}

The tricky part is how to implement `IsPoisoned` very fast and `ReportError` very compact.


=Memory mapping=
The virtual address space is divided into 2 disjoint classes:
  * Main application memory (`Mem`): this memory is used by the regular application code.
  * Shadow memory (`Shadow`): this memory contains the shadow values (or metadata). There is a correspondence between the shadow and the main application memory. *Poisoning* a byte in the main memory means writing some special value into the corresponding shadow memory.

These 2 classes of memory should be organized in such a way that
`MemToShadow` is fast.

The instrumentation performed by the compiler:
{{{
shadow_address = MemToShadow(address);
if (ShadowIsPoisoned(shadow_address)) {
  ReportError(address, kAccessSize, kIsWrite);
}
}}}

==Full mapping==
On 64-bit Linux, the virtual address space is usually divided into
two parts, `LowMem` and `HighMem`. `LowMem` starts from 0. `HighMem` ends with `2^48`.
We can also declare (almost arbitrary) upper bound for `LowMem` and lower bound for `HighMem`.
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||

The simplest mapping between `Mem` and `Shadow` is:
{{{
kLowShadowMask  = 0x0000040000000000;
kHighShadowMask = 0x0000600000000000;
Shadow = Mem | kLowShadowMask & ~kHighShadowMask;
}}}

This mapping ceates a byte-to-byte correspondence between the main and the shadow memory. The mapping looks like this:
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||
|| `[0x00001f0000000000, 0x0000200000000000)` || `HighShadow` ||
|| `[0x0000040000000000, 0x0000080000000000)` || `LowShadow`  ||
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||

Poisoning a byte in main memory means writing a non-zero value into the corresponding shadow value. The instrumentation looks like this:
{{{
// BEFORE
void write(int *a) {
  *a = 0;
}
}}}
{{{
// AFTER (64 bit)
void write(int *a) {
  uintptr_t shadow_address = (uintptr_t)a;
  shadow_address |=  0x0000040000000000;
  shadow_address &= ~0x0000600000000000;
  shadow_address += 64; // to avoid cache bank conflicts.
  if (*(int*)(shadow_address)) {
    ReportError(address, kAccessSize, kIsWrite);
  }
  *a = 0;
}
}}}


==Compact mapping==
Byte-to-byte correspondence between the main and the shadow memory 
introduces 2x memory overhead. It is desirable to have more compact byte-to-bit correspondence
or, in fact, *qword-to-byte correspondence* (i.e. one 8-byte qword of the main memory corresponds
to one byte of shadow memory) because bits are not addressable and extracting bits might be slow. 

It should be noted, that there are only 9 different values for 
a shadow byte in qword-to-byte mapping:
  * All 8 bytes in qword are unpoisoned (i.e. addressible). The shadow value is 0.
  * All 8 bytes in qword are poisoned (i.e. not addressible). The shadow value is 8 or any larger value.
  * First `k` bytes are unpoisoned, the rest are poisoned. The shadow value is `k`.

This is guaranteed by the fact that `malloc` returns 8-byte aligned chunks of memory.
The only case where different bytes of an aligned qword have different state is the tail of 
a malloc-ed region. For example, if we call `malloc(13)`, we will have one full unpoisoned
qword and one qword where 5 first bytes are unpoisoned.

For the compact mapping the instrumentation look like this:
{{{
byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
if (shadow_value) {
  if (SlowPathCheck(shadow_value, address, kAccessSize)) {
    ReportError(address, kAccessSize, kIsWrite);
  }
}
}}}

{{{
// Check the cases where we access first k bytes of the qword
// and these k bytes are unpoisoned.
bool SlowPathCheck(shadow_value, address, kAccessSize) {
  last_addressed_byte = (address & 7) + kAccessSize;
  return last_addressed_byte > shadow_value);
}
}}}

The compact mapping uses less memory, but has more code on the slow path.
Also the compact mapping will not catch unaligned partially out-of-bound accesses:
{{{
  int *x = new int;  // allocates 4 bytes:   [0,4).
  int *unaligned = (int*)((char*)x + 2);
  // This is an out-of-bound access of range [2-6),
  *unaligned = 1;
}}}

===64-bit compact===
|| `[0x00007f0000000000, 0x00007fffffffffff]` || `HighMem`    ||
|| `[0x00001fe000000000, 0x00001fffffffffff]` || `HighShadow` ||
|| `[0x0000100000000000, 0x0000101000000000)` || `LowShadow`  ||
|| `[0x0000000000000000, 0x0000008000000000)` || `LowMem`     ||

{{{
Shadow = (Mem >> 3) | 0x0000100000000000;
}}}

===32 bit===
The 32-bit address space is scarce and full (byte-to-byte) mapping seems to be
impossible to implement reasonably fast.

Regular Linux 32-bit address space:

|| `[0x40000000, 0xffffffff]` || `HighMem`          ||
|| `[0x30000000, 0x3fffffff]` || `HighShadow`       ||
|| `[0x20000000, 0x23ffffff]` || `LowShadow`        ||
|| `[0x00000000, 0x1fffffff]` || `LowMem`           ||

CrOS (32-bit, uses `CONFIG_VMSPLIT_2G=y` kernel config option):

|| `[0x30000000, 0x7fffffff]` || `HighMem`          ||
|| `[0x26000000, 0x2fffffff]` || `HighShadow`       ||
|| `[0x20000000, 0x23ffffff]` || `LowShadow`        ||
|| `[0x00000000, 0x1fffffff]` || `LowMem`           ||

For both cases the shadow mapping is the same:
{{{
Shadow = (Mem >> 3) | 0x20000000;
}}}

==Report Error==
The `ReportError` could be implemented as a call, but there are many other,
more efficient and/or compact solutions.
Currently, we do the following:
  * copy the failure address to `%rax`
  * execute `ud2` (generates SIGILL)
  * Encode access type and size in a one-byte instruction which follows `ud2`.

== Example of instrumented code ==
{{{
// instrumenting a 64-bit store instruction
0:    48 89 f9                mov    %rdi,%rcx
3:    48 c1 e9 03             shr    $0x3,%rcx
7:    48 b8 00 00 00 00 00    mov    $0x100000000000,%rax
e:    10 00 00
11:   48 09 c8                or     %rcx,%rax
14:   80 38 00                cmpb   $0x0,(%rax)  << load shadow
17:   75 08                   jne    21
19:   48 c7 07 01 00 00 00    movq   $0x1,(%rdi)  << original store instruction
20:   c3                      retq
21:   48 89 f8                mov    %rdi,%rax    << save the address in %rax
24:   0f 0b                   ud2a                << generate SIGILL
26:   5b                      pop    %rbx         << Encode access size and type in the insturction
}}}


= Run-time library =
==Malloc==
The run-time library replaces `malloc`, `free` and similar functions and sets SEGV handler.

`malloc` allocates the requested amount of memory with redzones around it.
The shadow values corresponding to the redzones are poisoned
and the shadow values for the main memory region are cleared.

`free` poisons shadow values for the entire region and puts the chunk of memory
into a quarantine queue (such that this chunk
will not be returned again by malloc during some period of time).

SEGV handler extracts the failing address, access type/size and prints the error message.


=Misc=
==In-Memory poisoning==
It is possible to poison the memory itself instead of using
shadow memroy. This will make the instrumentation even cheaper,
but may require more sophisticated run-time library
and may appear more fragile.



