#summary AddressSanitizer algorithm

<wiki:toc max_depth="3" />

=Short version=
The run-time library replaces the `malloc` and `free` functions.
The memory around malloc-ed regions (red zones) is poisoned. 
The `free`-ed memory is placed in quarantine and also poisoned.
Every memory access in the program is transformed by the compiler in the following way:

Before:
{{{
*address = ...;  // or: ... = *address;
}}}
After:
{{{
if (IsPoisoned(address) {
  GeneratePageFault(address);
}
*address = ...;  // or: ... = *address;
}}}

The tricky part is how to implement `IsPoisoned` very fast.


=Memory mapping=
The virtual address space is divided into 2 disjoint classes:
  * Main application memory (`Mem`): this memory is used by the regular application code.
  * Shadow memory (`Shadow`): this memory contains the shadow values (or metadata). There is a correspondence between the shadow and the main application memory. *Poisoning* a byte in the main memory means writing some special value into the corresponding shadow memory.

These 2 classes of memory should be organized in such a way that
`MemToShadow` is fast and reversible
(i.e. it is possible to implement `ShadowToMem`).

The instrumentation performed by the compiler:
{{{
shadow_address = MemToShadow(address);
if (IsPoisoned(shadow_address)) {
  // Put 'address' somewhere.
  *(uintptr_t)kSomeFixedAddress = address;
  // Now crash.
  *(uintptr_t)(0xfff) = kAccessSize + 16 * kAccessIsWrite; // crash
}
}}}

Once the page fault happens and SEGV is caught, we have the PC where the fault occurred.
This gives us the access type (read or write) and size.
The failing address is stored in some fixed address (basically, a global).

==Full mapping==
On 64-bit Linux, the virtual address space is usually divided into
two parts, `LowMem` and `HighMem`. `LowMem` starts from 0. `HighMem` ends with `2^48`.
We can also declare (almost arbitrary) upper bound for `LowMem` and lower bound for `HighMem`.
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||

The simplest mapping functions are as follows:
{{{
kLowShadowMask  = 0x0000040000000000;
kHighShadowMask = 0x0000600000000000;
MemToShadow(Mem) {
  return = Mem | kLowShadowMask & ~kHighShadowMask;
}

ShadowToMem(Shadow)
  return (Shadow < kLowShadowMask *2)
         ? (Shadow & ~kLowShadowMask)
         : (Shadow | kHighShadowMask);
}
}}}

These functions create a byte-to-byte correspondence between the main and the shadow memory. The mapping looks like this:
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||
|| `[0x0000040000000000, 0x0000080000000000)` || `LowShadow`  ||
|| `[0x00001f0000000000, 0x0000200000000000)` || `HighShadow` ||
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||

Poisoning a byte in main memory means writing a non-zero value into the corresponding shadow value. The instrumentation looks like this:
{{{
// BEFORE
void write(int *a) {
  *a = 0;
}
}}}
{{{
// AFTER (64 bit)
void write(int *a) {
  uintptr_t shadow_address = (uintptr_t)a;
  shadow_address |=  0x0000040000000000;
  shadow_address &= ~0x0000600000000000;
  shadow_address += 64; // to avoid cache bank conflicts.
  if (*(int*)(shadow_address)) {
    // - put the effective address 'a' somewhere
    // - put the access size and type somwehere
    // - crash
    // One way to do all that in two instructions:
    *(uintptr_t*)kLowShadowMask = a;
    *(uintptr_t*)0xfff = kAccessIsWrite * 64 + kAccessSize;
  }
  *a = 0;
}
}}}

Example of instrumented code:
{{{
// 64 bit
0:   48 b9 ff ff ff ff ff    mov    $0xffff9bffffffffff,%rcx
7:   9b ff ff
a:   48 21 f9                and    %rdi,%rcx
d:   48 b8 00 00 00 00 00    mov    $0x40000000000,%rax
14:   04 00 00
17:   48 09 c1                or     %rax,%rcx
1a:   48 83 79 40 00          cmpq   $0x0,0x40(%rcx)    <<< read the shadow
1f:   74 0b                   je     2c <write_int_1+0x2c>
21:   48 89 38                mov    %rdi,(%rax)        <<< store the address
24:   c6 04 25 ff 0f 00 00    movb   $0x48,0xfff        <<< CRASH!
2b:   48
2c:   48 c7 07 01 00 00 00    movq   $0x1,(%rdi)
}}}

==Compact mapping==
Byte-to-byte correspondence between the main and the shadow memory 
introduces 2x memory overhead. It is desirable to have more compact byte-to-bit correspondence
or, in fact, *qword-to-byte correspondence* (i.e. one 8-byte qword of the main memory corresponds
to one byte of shadow memory) because bits are not addressable and extracting bits might be slow. 

It should be noted, that there are only 9 different values for 
a shadow byte in qword-to-byte mapping:
  * All 8 bytes in qword are unpoisoned (i.e. addressible). The shadow value is 0.
  * All 8 bytes in qword are poisoned (i.e. not addressible). The shadow value is 8 or any larger value.
  * First `k` bytes are unpoisoned, the rest are poisoned. The shadow value is `k`.

This is guaranteed by the fact that `malloc` returns 8-byte aligned chunks of memory.
The only case where different bytes of an aligned qword have different state is the tail of 
a malloc-ed region. For example, if we call `malloc(13)`, we will have one full unpoisoned
qword and one qword where 5 first bytes are unpoisoned.

For the compact mapping the instrumentation look like this:
{{{
byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
if (shadow_value) {
  if (SlowPathCheck(shadow_value, address, kAccessSize)) {
    // store the address and crash
  }
}
}}}

{{{
// Check the cases where we access first k bytes of the qword
// and these k bytes are unpoisoned.
bool SlowPathCheck(shadow_value, address, kAccessSize) {
  last_addressed_byte = (address & 7) + kAccessSize;
  return last_addressed_byte > shadow_value);
}
}}}

The compact mapping uses less memory, but has more code on the slow path.
Also the compact mapping will not catch unaligned partially out-of-bound accesses:
{{{
  int *x = new int;  // allocates 4 bytes:   [0,4).
  int *unaligned = (int*)((char*)x + 2);
  // This is an out-of-bound access of range [2-6),
  *unaligned = 1;
}}}

===64-bit compact===
|| `[0x0000000000000000, 0x0000008000000000)` || `LowMem`     ||
|| `[0x0000100000000000, 0x0000101000000000)` || `LowShadow`  ||
|| `[0x00001fe000000000, 0x00001fffffffffff]` || `HighShadow` ||
|| `[0x00007f0000000000, 0x00007fffffffffff]` || `HighMem`    ||

{{{
Shadow = (Mem >> 3) | 0x0000100000000000;
}}}

===32 bit===
The 32-bit address space is scarce, full (byte-to-byte) mapping seems to be
impossible to implement reasonably fast.

Regular Linux 32-bit address space:

|| `[0x00000000, 0x1fffffff]` || `LowMem`           ||
|| `[0x20000000, 0x23ffffff]` || `LowShadow`        ||
|| `[0x30000000, 0x3fffffff]` || `HighShadow`       ||
|| `[0x80000000, 0xffffffff]` || `HighMem`          ||

{{{
Shadow = (Mem >> 3) | 0x20000000;
Mem = (Shadow & ~0x20000000) << 3;
}}}

CrOS (32-bit, uses `CONFIG_VMSPLIT_2G=y` kernel config option):

|| `[0x00000000, 0x1fffffff]` || `LowMem`           ||
|| `[0x20000000, 0x23ffffff]` || `LowShadow`        ||
|| `[0x26000000, 0x2fffffff]` || `HighShadow`       ||
|| `[0x30000000, 0x7fffffff]` || `HighMem`          ||

{{{
Shadow = (Mem >> 3) | 0x20000000;
Mem = (Shadow & ~0x20000000) << 3
}}}

= Run-time library =
==Malloc==
The run-time library replaces `malloc`, `free` and similar functions and sets SEGV handler.

`malloc` allocates the requested amount of memory with redzones around it.
The shadow values corresponding to the redzones are poisoned
and the shadow values for the main memory region are cleared.

`free` poisons shadow values for the entire region and puts the chunk of memory
into a quarantine queue (such that this chunk
will not be returned again by malloc during some period of time).

SEGV handler extracts the failing address, access type/size and prints the error message.


=Misc=
==In-Memory poisoning==
It is possible to poison the memory itself instead of using
shadow memroy. This will make the instrumentation even cheaper,
but may require more sophisticated run-time library
and may appear more fragile.



