#summary AddressSanitizer algorithm

=Short version=
The run-time library replaces the `malloc` and `free` functions.
The memory around malloc-ed regions (red zones) is poisoned. 
The `free`-ed memory is placed in quarantine and also poisoned.
Every memory access in the program is transformed by the compiler in the following way:

Before:
{{{
*address = ...;
}}}
After:
{{{
if (IsPoisoned(address) {
  GeneratePageFault(address);
}
*address = ...;
}}}

The tricky part is how to implement `IsPoisoned` very fast.


=Memory mapping=
The virtual address space is divided into 3 disjoint classes:
  * Main application memory (`Mem`): this memory is used by the regular application code.
  * Shadow memory (`Shadow`): this memory contains the shadow values (or metadata). There is a correspondence between the shadow and the main application memory. *Poisoning* a byte in the main memory means writing some special value into the corresponding shadow memory.
  * Bad unmapped memory (`Bad`): access to this memory causes SEGV.

These 3 classes of memory should be organized in such a way that 
`MemToShadow` and `ShadowToBad` are fast and reversible 
(i.e. it is possible to implement `ShadowToMem` and `BadToShadow`).

The instrumentation performed by the compiler:
{{{
shadow_address = MemToShadow(address);
if (IsPoisoned(shadow_address)) {
  bad_address = ShadowToMem(shadow_address);
  *bad_address = kAccessSize + 16 * kAccessIsWrite;
}
}}}

Once the page fault happens and SEGV is caught, we have the PC and the address 
where the fault occurred.
The failing address is `bad_address`, which allows us to compute `ShadowToMem(BadToShadow(bad_address))`
and provide the information about the original application address (e.g. where it has been allocated or deallocated). The PC allows us to disassemble the failing instruction 
and extract `kAccessSize` and `kAccessIsWrite` (on x86 they are encoded as one of the instruction bytes).

==64 bit==
On 64-bit Linux, the virtual address space is usually divided into 
two parts, `LowMem` and `HighMem`. `LowMem` starts from 0. `HighMem` ends with `2^48`.
We can also declare (almost arbitrary) upper bound for `LowMem` and lower bound for `HighMem`.
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||

The simplest mapping functions are as follows:
{{{
kLowShadowMask  = 0x0000040000000000;
kHighShadowMask = 0x0000600000000000;
MemToShadow(Mem) {
  return = Mem | kLowShadowMask & ~kHighShadowMask;
}

ShadowToMem(Shadow)
  return (Shadow < kLowShadowMask *2)
         ? (Shadow & ~kLowShadowMask)
         : (Shadow | kHighShadowMask);
}

ShadowToBad(Shadow) {
  return Shadow * 2;
}

BadToShadow(Bad{
  return Bad / 2;
}
}}}

These functions create a byte-to-byte correspondence between the main and the shadow memory. The mapping looks like this:
|| `[0x0000000000000000, 0x0000040000000000)` || `LowMem`     ||
|| `[0x0000040000000000, 0x0000080000000000)` || `LowShadow`  ||
|| `[0x0000080000000000, 0x0000100000000000)` || `LowBad`     ||
|| `[0x00001f0000000000, 0x0000200000000000)` || `HighShadow` ||
|| `[0x00003e0000000000, 0x0000400000000000)` || `HighBad`    ||
|| `[0x00007f0000000000, 0x0000800000000000)` || `HighMem`    ||

Poisoning a byte in main memory means writing a non-zero value into the corresponding shadow value. The instrumentation looks like this:
{{{
// BEFORE
void write(int *a) {
  *a = 0;
}
}}}
{{{
// AFTER (64 bit)
void write(int *a) {
  uintptr_t shadow_address = (uintptr_t)a;
  shadow_address |=  0x0000040000000000;
  shadow_address &= ~0x0000600000000000;
  shadow_address += 64; // to avoid cache bank conflicts.
  if (*(int*)(shadow_address)) {
    char *bad_address = (char*)(shadow_address * 2);
    *bad_address = kAccessSize + 16 * kAccessIsWrite;
  }
  *a = 0;
}
}}}

Example of instrumented code:
{{{
// 64 bit
0:    48 b8 00 00 00 00 00    mov    $0x40000000000,%rax
7:    04 00 00
a:    48 09 f8                or     %rdi,%rax
d:    48 b9 ff ff ff ff ff    mov    $0xffff9fffffffffff,%rcx
14:   9f ff ff
17:   48 21 c1                and    %rax,%rcx            
1a:   83 79 40 00             cmpl   $0x0,0x40(%rcx)      <<< %rcx is the shadow address
1e:   74 04                   je     24 <write_int_1+0x24>
20:   c6 04 09 14             movb   $0x14,(%rcx,%rcx,1)  <<< kAccessIsWrite and kAccessSize
24:   c7 07 01 00 00 00       movl   $0x1,(%rdi)          <<< original instruction
}}}

==64 bit compact==
Byte-to-byte correspondence between the main and the shadow memory 
introduces 2x memory overhead. It is desirable to have more compact byte-to-bit correspondence
or, in fact, *qword-to-byte correspondence* (i.e. one 8-byte qword of the main memory corresponds
to one byte of shadow memory) because bits are not addressable and extracting bits might be slow. 

It should be noted, that there are only 9 different values for 
a shadow byte in qword-to-byte mapping:
  * All 8 bytes in qword is unpoisoned (i.e. addressible)
  * All 8 bytes in qword are poisoned (i.e. not addressible)
  * First `k` bytes are unpoisoned, the rest are poisoned. 
This is guaranteed by the fact that `malloc` returns 8-byte aligned chunks of memory. 
The only case where different bytes of an aligned qword have different state is the tail of 
a malloc-ed region. For example, if we call `malloc(13)`, we will have one full unpoisoned
qword and one qword where 5 first bytes are unpoisoned.


==32 bit==
