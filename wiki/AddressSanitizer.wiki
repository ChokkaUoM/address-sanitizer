#summary AddressSanitizer: a fast memory error detector

<wiki:toc max_depth="2" />


=Introduction=

Many tools for finding memory bugs exist. <BR>
[http://www.valgrind.org Valgrind], [http://code.google.com/p/drmemory/ DrMemory],
[http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging Mudflap], 
[http://en.wikipedia.org/wiki/Electric_Fence  Electric Fence], Purify, Intel Inspector are among them. 
All these tools share the same problem -- they are slow. 

We propose a new tool called AddressSanitizer (*ASan*) which finds
*out-of-bound* (for heap, stack and globals) and *use-after-free* bugs.
The key advantage of this tool is that it is [PerformanceNumbers very fast] (~2x slowdown in most cases).
The tool consists of a compiler instrumentation module (currently, an LLVM pass)
and a run-time library which replaces the `malloc` function.

The tool is still under development but it already can run the
Chromium browser (on Linux and Mac) and find bugs in it.

See also:
  * AddressSanitizerAlgorithm -- if you are curious how it works.
  * ToDo -- if you want to help.

=Getting !AddressSanitizer=
If you want to build AddressSanitizer yourself, refer to HowToBuild.

We periodically update the AddressSanitizer binaries at the Chromium svn:
{{{
% svn co http://src.chromium.org/svn/trunk/deps/third_party/asan
}}}

So far, AddressSanitizer has been tested only on Linux Ubuntu 10.04, 64-bit
(it can run both 64- and 32-bit programs) and Mac 10.6.

= Using !AddressSanitizer =
In order to use AddressSanitizer you will need to build your program
with the modified `clang` binary using the `-fasan` switch.
You also need to use `-O1` or higher optimization level.
{{{
% cat tests/use-after-free.c
#include <stdlib.h>
int main() {
  char *x = (char*)malloc(10 * sizeof(char*));
  free(x);
  return x[5];
}
% ../clang_build_Linux/Release+Asserts/bin/clang -fasan -O2 -g   tests/use-after-free.c
}}}

Now, run the executable.

{{{
% ./a.out
==22420== ERROR: AddressSanitizer crashed on address 0x0000200000703c18 at pc 0x401947
READ of size 1 at 0x0000200000703c18; shadow: 0x0000100000381e0c; mem: 0x0000000001c0f065 thread: 0x787d4720
    #0 0x401947 main use-after-free.c:5
    #1 0x7ff87792cc4d __libc_start_main ??:0
    #2 0x401839 _start ??:0
0x0000000001c0f065 is located 5 bytes inside of 80-byte region [0x0000000001c0f060,0x0000000001c0f0b0)
freed by thread 0x787d4720 here:
    #0 0x404b9b free asan_rtl.cc:1203
    #1 0x40191b main use-after-free.c:5
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
previously allocated by thread 0x787d4720 here:
    #0 0x405c27 malloc asan_rtl.cc:1196
    #1 0x401910 main use-after-free.c:3
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
}}}

=Interaction with other tools=
==gdb==
You can use [http://www.gnu.org/software/gdb/ gdb] with 
binaries built by AddressSanitizer in a usual way.
When AddressSanitizer finds a bug it generates `SIGILL` so gdb will 
stop before AddressSanitizer prints a warning.

{{{
% gdb -q ./a.out
Reading symbols from a.out...done.
(gdb) r
Starting program: a.out
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/libthread_db.so.1".
0x0000000000402ed7 in main () at ./use-after-free.c:5
5         return x[5];
(gdb) c
Continuing.
==19123== ERROR: AddressSanitizer crashed on address 0x000000000103a325 at pc 0x402ed7 bp 0x7fffffffe650 sp 0x7fffffffe640
READ of size 1 at 0x000000000103a325 thread T0
    #0 0x402ed7 in main use-after-free.c:5
    #1 0x7ffff712cc4d in __libc_start_main ?:0
    #2 0x402dc9 in _start ?:0
...
}}}

==ulimit -v==
The `ulimit -v` command can be used with ASan-ified binaries.
However, you should remember that ASan consumes 16 terabytes of virtual memory for shadow state and the `ulimit -v` value should be set accordingly.
For example, the following script may be used as a wrapper for `ulimit -v`:
{{{
#!/bin/bash
LIMIT_IN_GIGABYTES=$1
shift
# The value to pass to ulimit is 2^44+$LIMIT_IN_GIGABYTES bytes
ASAN_LIMIT=$(echo "(2^44 + $LIMIT_IN_GIGABYTES * 2^30) / 2^10" | bc -q)
echo ASAN_LIMIT: $ASAN_LIMIT
ulimit -v $ASAN_LIMIT
"$@"
}}}


=Flags=

Compile-time flags are passed via clang flag `-mllvm <flag>`.
|| flag|| default || description ||
|| -asan-stack   || 1 || Detect overflow/underflow for stack objects ||
|| -asan-globals || 1 || Detect overflow/underflow for global objects (see [KnownBugs])   ||
|| -asan-blacklist ||  || Pass a [#BlackList_file blacklist file] ||


Most run-time flags are passed to AddressSanitizer via `ASAN_OPTIONS` environment variable like this: 
{{{
ASAN_OPTIONS=v=1 ./a.out
}}}

|| flag|| default || description ||
|| v  || 0 || Be more verbose (mostly for testing the tool itself) ||
|| malloc_context_size || 16 || Number of frames in `malloc`/`free` stack traces. ||
|| fast_unwind || 1 || Use fast Unwind. See also [#Call_stack Call stack] ||
|| || || ||

=Call stack=
AddressSanitizer collects call stacks on the following events:
  * `malloc` and `free`
  * thread creation
  * failure

`malloc` and `free` happen relatively frequently and it is important to unwind the call stack fast.
By default, a fast and somewhat unreliable unwinder based on frame pointers is used.
If you see short or garbled call stacks, disable the fast unwinder (`fast_unwind=0`).
The slow unwinder uses `libunwind` and is ... really slow.

If you don't care about `malloc`/`free` call stacks, simply disable the unwinder completely
(`malloc_context_size=0`).
For infrequent events (thread creation, failure) we always use the slow unwinder.

Each stack frame needs to be symbolized (of course, if the binary is compiled with debug info).
Given a PC, we need to print
{{{
  #0xabcdf function_name file_name.cc:1234
}}}
<wiki:comment>
[http://llvm.org/bugs/show_bug.cgi?id=7554 LLVM issue].
</wiki:comment>
Currently, AddressSanitizer does not have an in-process symbolizer.
You will need to filter the log file through `scripts/asan_symbolize.py` to get the symbols.
This script takes an optional parameter -- a file prefix.
The substring `.*prefix` will be removed from the file names.
{{{
% ./a.out
    ...
    #0 0x402c77 (/home/you/address-sanitizer/asan/a.out+0x402c77)
    ...
% ./a.out 2>&1  | ../scripts/asan_symbolize.py
   ...
   #0 0x402c77 in main /home/you/address-sanitizer/asan/use-after-free.c:5
   ...
% ./a.out 2>&1  | ../scripts/asan_symbolize.py /you/
   ...
   #0 0x402c77 in main address-sanitizer/asan/use-after-free.c:5
   ...
}}}

=Blacklist file=
In some cases a particular function should be ignored (not instrumented) by AddressSanitizer.
One of the reasons is speed (e.g. a hot function known to be correct).
Another reason is to avoid reporting known problems.

To ignore certain functions, create a file `my_ignores.txt` and pass it to AddressSanitizer
at compile time using `-mllvm -asan-blacklist=my_ignores.txt`:
{{{
# Ignore exactly this function (the names are mangled)
fun:MyFooBar
# Ignore MyFooBar(void) if it is in C++:
fun:_Z8MyFooBarv
# Ignore all function containing MyFooBar
fun:*MyFooBar*
}}}

=Comments?=
Send comments to address-sanitizer@googlegroups.com
