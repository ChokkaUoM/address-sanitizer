#summary AddressSanitizer: a fast memory error detector

<wiki:toc max_depth="1" />


=Introduction=

Many tools for finding memory bugs exist. <BR>
[http://www.valgrind.org Valgrind], [http://code.google.com/p/drmemory/ DrMemory],
[http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging Mudflap], 
[http://en.wikipedia.org/wiki/Electric_Fence  Electric Fence], Purify, Intel Inspector are among them. 
All these tools share the same problem -- they are slow. 

We propose a new tool called AddressSanitizer (*asan*) which finds 
*out-of-bound* (both stack and heap) and *use-after-free* bugs.
The key advantage of this tool is that it is very fast (~2x slowdown in most cases).
The tool consists of a compiler instrumentation module (currently, an LLVM pass)
and a run-time library which replaces the `malloc` function. 

The tool is in early stage of development but it already can run the Chromium browser (on Linux) and find bugs in it.

See also:
  * AddressSanitizerAlgorithm -- if you are curious how it works.
  * ToDo -- if you want to help.

=Building AddressSanitizer=
The following will build the modified `clang` binary and run tests.
Getting and building LLVM/Clang will take some time.
{{{
svn checkout http://address-sanitizer.googlecode.com/svn/trunk/ address-sanitizer
cd address-sanitizer
./llvm/get_clang.sh
./llvm/patch_clang.sh
./llvm/build_clang.sh
cd asan
make -j && ./asan_test32 && ./asan_test64 && ./asan_test64full
}}}

So far, AddressSanitizer has been tested only on Linux Ubuntu 10.04, 64-bit
(it can run both 64- and 32-bit programs).
We plan to support Mac as well (Mac variant worked at some point), but we are not there yet.

= Using AddressSanitizer =
In order to use AddressSanitizer you will need to build your program
with the modified `clang` binary and tell it where the run-time library resides.
{{{
% cat use-after-free.c
#include <stdlib.h>
int main() {
  char *x = (char*)malloc(10 * sizeof(char*));
  free(x);
  return x[5];
}
% ASAN_LIB=libasan64.a ../clang_build/Release+Asserts/bin/clang -O2 -g   use-after-free.c
}}}

Now, run the executable.

{{{
% ./a.out
==22420== ERROR: AddressSanitizer crashed on address 0x0000200000703c18 at pc 0x401947
READ of size 1 at 0x0000200000703c18; shadow: 0x0000100000381e0c; mem: 0x0000000001c0f065 thread: 0x787d4720
    #0 0x401947 main use-after-free.c:5
    #1 0x7ff87792cc4d __libc_start_main ??:0
    #2 0x401839 _start ??:0
 0x0000000001c0f065 is the address located 5 bytes inside of region:
[0x0000000001c0f060,0x0000000001c0f0b0) -- allocated memory of 0x50 (80) bytes
freed by thread 0x787d4720 here:
    #0 0x404b9b free asan_rtl.cc:1203
    #1 0x40191b main use-after-free.c:5
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
previously allocated by thread 0x787d4720 here:
    #0 0x405c27 malloc asan_rtl.cc:1196
    #1 0x401910 main use-after-free.c:3
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
}}}

=Flags=

Compile-time flags are passed via clang flag `-mllvm <flag>`.
|| flag|| default || description ||
|| -asan || 1 || enable AddressSanitizer ||
|| -asan-stack || 1 || Enable stack poisoning. Currently does *not* work in presence of EH or longjmp ||


Most run-time flags are passed to AddressSanitizer via `ASAN_OPTIONS` environment variable like this: 
{{{
ASAN_OPTIONS=v=1:red_zone_words=24:symbolize=0 ./a.out
}}}

|| flag|| default || description ||
|| v  || 0 || Be more verbose (mostly for testing the tool itself) ||
|| red_zone_words || 16 || Size of malloc redzones (in words)  ||
|| malloc_context_size || 16 || Number of frames in `malloc`/`free` stack traces. Can not be greater than `red_zone_words`.||
|| fast_unwind || 1 || Use fast Unwind. See also [#Call_stack Call stack] ||
|| symbolize|| 1  || Use builtin symbolizer based on libbfd. See also [#Call_stack Call stack]||
|| demangle || 1 || Demangle function names (if symbolize=1) ||
|| || || ||

=Call stack=
AddressSanitizer collects call stacks on the following events:
  * `malloc` and `free`
  * thread creation
  * failure

`malloc` and `free` happen relatively frequently and it is important to unwind the call stack fast.
By default, a fast and somewhat unreliable unwinder based on frame pointers is used.
If you see short or garbled call stacks, disable the fast unwinder (`fast_unwind=0`).
The slow unwinder uses `libunwind` and is ... really slow.

If you don't care about `malloc`/`free` call stacks, simply disable the unwinder completely
(`malloc_context_size=0`).
For infrequent events (thread creation, failure) we always use the slow unwinder.

Each stack frame needs to be symbolized. Given a PC, we need to print
{{{
  #0xabcdf function_name, file_name.cc:1234
}}}
By default, we use a built-in symboilzer based on `libbfd`.
It may be very slow on large binaries due to [http://llvm.org/bugs/show_bug.cgi?id=7554 LLVM issue]. 
You may want to disabled the symbolizer (`symbolize=0`) and after the run filter
the result may be filtered through `scripts/asan_symbolize.py` to get the symbols.

