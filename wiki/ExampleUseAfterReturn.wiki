#summary Example: UseAfterReturn
{{{
// By default, AddressSanitizer does not try to detect
// stack-use-after-return bugs.
// It may still find such bugs occasionally
// and report them as a hard-to-explain stack-buffer-overflow.

// This test is compiled with experimental flag -asan-use-after-return=-1
int *ptr;
void FunctionThatEscapesLocalObject() {
  int local[100];
  ptr = &local[0];
}

int main(int argc, char **argv) {
  FunctionThatEscapesLocalObject();
  return ptr[argc];
}
}}}
{{{
clang++ -O1 -faddress-sanitizer example_UseAfterReturn.cc
./a.out
}}}
{{{
=================================================================
==10638== ERROR: AddressSanitizer stack-use-after-return on address 0x7f9211380024 at pc 0x402594 bp 0x7fffa6cbd7b0 sp 0x7fffa6cbd7a8
READ of size 4 at 0x7f9211380024 thread T0
    #0 0x402594 in main example_UseAfterReturn.cc:15
    #1 0x7f921239ec4d in __libc_start_main ??:0
    #2 0x4023b9 in _start ??:0
Address 0x7f9211380024 is located at offset 36 in frame <FunctionThatEscapesLocalObject()> of T0's stack:
  This frame has 1 object(s):
    [32, 432) 'local'
HINT: this may be a false positive if your program uses some custom stack unwind mechanism
      (longjmp and C++ exceptions *are* supported)
==10638== ABORTING
Shadow byte and word:
  0x1ff242270004: f5
  0x1ff242270000: f5 f5 f5 f5 f5 f5 f5 f5
More shadow bytes:
  0x1ff24226ffe0: 00 00 00 00 00 00 00 00
  0x1ff24226ffe8: 00 00 00 00 00 00 00 00
  0x1ff24226fff0: 00 00 00 00 00 00 00 00
  0x1ff24226fff8: 00 00 00 00 00 00 00 00
=>0x1ff242270000: f5 f5 f5 f5 f5 f5 f5 f5
  0x1ff242270008: f5 f5 f5 f5 f5 f5 f5 f5
  0x1ff242270010: f5 f5 f5 f5 f5 f5 f5 f5
  0x1ff242270018: f5 f5 f5 f5 f5 f5 f5 f5
  0x1ff242270020: f5 f5 f5 f5 f5 f5 f5 f5
}}}
